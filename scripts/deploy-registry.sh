#!/bin/bash
# Production Deployment Script using Container Registry Images
# This script deploys Prism DNS using images from GitHub Container Registry

set -euo pipefail

# Configuration
REGISTRY="ghcr.io"
REGISTRY_NAMESPACE="${GITHUB_REPOSITORY_OWNER:-manageddns}"
DEFAULT_TAG="latest"
COMPOSE_FILE="docker-compose.registry.yml"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Help function
show_help() {
    cat << EOF
Prism DNS Registry Deployment Script

USAGE:
    $0 [OPTIONS]

OPTIONS:
    -t, --tag TAG           Image tag to deploy (default: latest)
    -n, --namespace NAME    Registry namespace (default: \$GITHUB_REPOSITORY_OWNER)
    -f, --file FILE         Docker compose file (default: docker-compose.registry.yml)
    -d, --dry-run          Show what would be deployed without executing
    -p, --pull             Force pull images before deployment
    -s, --stop             Stop and remove current deployment
    -h, --help             Show this help message

EXAMPLES:
    # Deploy latest images
    $0

    # Deploy specific version
    $0 --tag v1.2.3

    # Deploy from different namespace
    $0 --namespace myorg

    # Dry run to see what would be deployed
    $0 --dry-run --tag v1.2.3

    # Stop current deployment
    $0 --stop

ENVIRONMENT VARIABLES:
    GITHUB_REPOSITORY_OWNER - Default registry namespace
    DB_PASSWORD            - Database password (required)
    LOG_LEVEL             - Logging level (default: INFO)

EOF
}

# Parse command line arguments
TAG="$DEFAULT_TAG"
NAMESPACE="$REGISTRY_NAMESPACE"
DRY_RUN=false
FORCE_PULL=false
STOP_DEPLOYMENT=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -t|--tag)
            TAG="$2"
            shift 2
            ;;
        -n|--namespace)
            NAMESPACE="$2"
            shift 2
            ;;
        -f|--file)
            COMPOSE_FILE="$2"
            shift 2
            ;;
        -d|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -p|--pull)
            FORCE_PULL=true
            shift
            ;;
        -s|--stop)
            STOP_DEPLOYMENT=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
done

# Validation
if [[ -z "$NAMESPACE" ]]; then
    log_error "Registry namespace not set. Use --namespace or set GITHUB_REPOSITORY_OWNER"
    exit 1
fi

# Function to check if docker is available
check_docker() {
    if ! command -v docker &> /dev/null; then
        log_error "Docker is not installed or not in PATH"
        exit 1
    fi

    if ! docker info &> /dev/null; then
        log_error "Docker is not running or accessible"
        exit 1
    fi
}

# Function to check if docker-compose is available
check_docker_compose() {
    if command -v docker-compose &> /dev/null; then
        DOCKER_COMPOSE="docker-compose"
    elif docker compose version &> /dev/null; then
        DOCKER_COMPOSE="docker compose"
    else
        log_error "Docker Compose is not installed or not accessible"
        exit 1
    fi
}

# Function to create registry-based compose file
create_registry_compose() {
    local server_image="$REGISTRY/$NAMESPACE/prism-server:$TAG"
    local web_image="$REGISTRY/$NAMESPACE/prism-web:$TAG"
    
    log_info "Creating registry-based compose file..."
    
    cat > "$COMPOSE_FILE" << EOF
# Production Docker Compose using Container Registry Images
# Generated by deploy-registry.sh at $(date)

services:
  nginx:
    image: $web_image
    container_name: prism-nginx
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - prism-server
    restart: unless-stopped
    networks:
      - prism-frontend
      - prism-backend
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/nginx-health"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

  prism-server:
    image: $server_image
    container_name: prism-server
    ports:
      - "8080:8080"
    volumes:
      - server_data:/app/data
      - server_logs:/app/logs
      - ./config:/app/config:ro
    environment:
      - PRISM_ENV=production
      - PRISM_LOG_LEVEL=\${LOG_LEVEL:-INFO}
      - PRISM_DATABASE_PATH=/app/data/prism.db
      - PRISM_CONFIG_PATH=/app/config/server.yaml
      - PYTHONPATH=/app
      - PYTHONUNBUFFERED=1
    depends_on:
      - database
    restart: unless-stopped
    networks:
      - prism-backend
      - prism-frontend
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8081/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  database:
    image: postgres:15-alpine
    container_name: prism-database
    environment:
      - POSTGRES_DB=\${DB_NAME:-prism}
      - POSTGRES_USER=\${DB_USER:-prism}
      - POSTGRES_PASSWORD=\${DB_PASSWORD}
      - POSTGRES_INITDB_ARGS=--auth-host=md5
    volumes:
      - database_data:/var/lib/postgresql/data
      - database_logs:/var/log/postgresql
      - ./server/database/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    restart: unless-stopped
    networks:
      - prism-backend
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U \${DB_USER:-prism}"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

volumes:
  database_data:
    driver: local
  server_data:
    driver: local
  server_logs:
    driver: local
  database_logs:
    driver: local

networks:
  prism-frontend:
    driver: bridge
  prism-backend:
    driver: bridge
    internal: false
EOF

    log_success "Created $COMPOSE_FILE"
}

# Function to pull images
pull_images() {
    log_info "Pulling images from registry..."
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "DRY RUN: Would pull images with tag '$TAG'"
        return
    fi
    
    if ! $DOCKER_COMPOSE -f "$COMPOSE_FILE" pull; then
        log_error "Failed to pull images"
        exit 1
    fi
    
    log_success "Images pulled successfully"
}

# Function to deploy services
deploy_services() {
    log_info "Deploying services..."
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "DRY RUN: Would deploy services using $COMPOSE_FILE"
        return
    fi
    
    # Check required environment variables
    if [[ -z "${DB_PASSWORD:-}" ]]; then
        log_error "DB_PASSWORD environment variable is required"
        exit 1
    fi
    
    # Deploy services
    if ! $DOCKER_COMPOSE -f "$COMPOSE_FILE" up -d; then
        log_error "Failed to deploy services"
        exit 1
    fi
    
    log_success "Services deployed successfully"
}

# Function to stop services
stop_services() {
    log_info "Stopping services..."
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "DRY RUN: Would stop services"
        return
    fi
    
    if [[ -f "$COMPOSE_FILE" ]]; then
        $DOCKER_COMPOSE -f "$COMPOSE_FILE" down
        log_success "Services stopped"
    else
        log_warning "Compose file $COMPOSE_FILE not found"
    fi
}

# Function to show deployment status
show_status() {
    log_info "Deployment status:"
    echo ""
    echo "Registry: $REGISTRY"
    echo "Namespace: $NAMESPACE"
    echo "Tag: $TAG"
    echo "Compose File: $COMPOSE_FILE"
    echo ""
    
    if [[ "$DRY_RUN" == "true" ]]; then
        echo "Images that would be deployed:"
        echo "- $REGISTRY/$NAMESPACE/prism-server:$TAG"
        echo "- $REGISTRY/$NAMESPACE/prism-web:$TAG"
        echo "- postgres:15-alpine"
    else
        if command -v docker &> /dev/null && docker info &> /dev/null; then
            echo "Running containers:"
            docker ps --filter "name=prism-" --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"
        fi
    fi
}

# Function to run health checks
health_check() {
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "DRY RUN: Would perform health checks"
        return
    fi
    
    log_info "Performing health checks..."
    
    # Wait for services to start
    sleep 10
    
    # Check web interface
    if curl -sf http://localhost/ > /dev/null 2>&1; then
        log_success "Web interface is responding"
    else
        log_warning "Web interface is not responding"
    fi
    
    # Check API health
    if curl -sf http://localhost/api/health > /dev/null 2>&1; then
        log_success "API health check passed"
    else
        log_warning "API health check failed"
    fi
    
    # Check TCP server
    if nc -z localhost 8080 2>/dev/null; then
        log_success "TCP server is listening"
    else
        log_warning "TCP server is not responding"
    fi
}

# Main execution
main() {
    log_info "Prism DNS Registry Deployment"
    log_info "============================="
    
    # Pre-flight checks
    check_docker
    check_docker_compose
    
    # Show what will be deployed
    show_status
    
    if [[ "$STOP_DEPLOYMENT" == "true" ]]; then
        stop_services
        return
    fi
    
    # Create registry-based compose file
    create_registry_compose
    
    # Pull images if requested or if it's not a dry run
    if [[ "$FORCE_PULL" == "true" ]] || [[ "$DRY_RUN" == "false" ]]; then
        pull_images
    fi
    
    # Deploy services
    deploy_services
    
    # Run health checks
    if [[ "$DRY_RUN" == "false" ]]; then
        health_check
        echo ""
        log_success "Deployment completed successfully!"
        log_info "Web interface: http://localhost/"
        log_info "API health: http://localhost/api/health"
        log_info "TCP server: localhost:8080"
    else
        echo ""
        log_info "Dry run completed. Use without --dry-run to deploy."
    fi
}

# Run main function
main "$@"