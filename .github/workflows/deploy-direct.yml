name: Direct Deploy to EC2

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  EC2_HOST: 35.170.180.10
  EC2_USER: ubuntu
  SERVER_IMAGE: 'prism-server:latest'
  WEB_IMAGE: 'prism-web:latest'

jobs:
  build-and-deploy:
    name: Build and Deploy Directly to EC2
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build production server image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.production
          target: production
          push: false
          load: true
          tags: ${{ env.SERVER_IMAGE }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build web interface image
        uses: docker/build-push-action@v5
        with:
          context: ./web
          file: ./web/Dockerfile
          target: production
          push: false
          load: true
          tags: ${{ env.WEB_IMAGE }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Save Docker images
        run: |
          echo "üíæ Saving Docker images to tarballs..."
          docker save ${{ env.SERVER_IMAGE }} | gzip > prism-server.tar.gz
          docker save ${{ env.WEB_IMAGE }} | gzip > prism-web.tar.gz
          ls -lah *.tar.gz

      - name: Debug Environment
        run: |
          echo "üîç Debugging workflow environment..."
          echo "Repository: ${{ github.repository }}"
          echo "Actor: ${{ github.actor }}"
          echo "Event: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Workflow: ${{ github.workflow }}"
          
      - name: Setup SSH Authentication
        env:
          SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          echo "üîê Setting up SSH authentication..."
          
          # Create SSH directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Debug: Check if secret exists by checking its length
          echo "üîç Checking if EC2_SSH_KEY secret exists..."
          SECRET_LENGTH=$(echo -n "${SSH_KEY}" | wc -c)
          echo "Secret length: ${SECRET_LENGTH} characters"
          
          if [ "$SECRET_LENGTH" -lt 10 ]; then
            echo "‚ùå EC2_SSH_KEY secret appears to be empty or too short!"
            echo "Please ensure the secret is properly set in GitHub repository settings."
            echo "To set it, run: gh secret set EC2_SSH_KEY < citadel.pem"
            exit 1
          fi
          
          # Save SSH key with multiple format attempts
          echo "üìù Attempting to save SSH key..."
          
          # Method 1: Use environment variable
          echo "${SSH_KEY}" > ~/.ssh/deploy_key
          
          # Ensure proper permissions
          chmod 600 ~/.ssh/deploy_key
          
          # Debug: Check key file
          echo "üîç Key file info:"
          ls -la ~/.ssh/deploy_key
          echo "First line of key:"
          head -n 1 ~/.ssh/deploy_key
          echo "Last line of key:"
          tail -n 1 ~/.ssh/deploy_key
          echo "Line count:"
          wc -l ~/.ssh/deploy_key
          
          # Try to extract public key (this will fail if format is wrong)
          echo "üîë Testing key format..."
          if ssh-keygen -y -f ~/.ssh/deploy_key > ~/.ssh/deploy_key.pub 2>/dev/null; then
            echo "‚úÖ SSH key format appears valid"
            echo "Public key:"
            cat ~/.ssh/deploy_key.pub
          else
            echo "‚ùå SSH key format is invalid!"
            echo "Common issues:"
            echo "1. Key should start with '-----BEGIN RSA PRIVATE KEY-----' or '-----BEGIN OPENSSH PRIVATE KEY-----'"
            echo "2. Key should end with '-----END RSA PRIVATE KEY-----' or '-----END OPENSSH PRIVATE KEY-----'"
            echo "3. Each line should be no more than 64 characters (except first and last)"
            echo "4. No extra spaces or characters"
            echo ""
            echo "Attempting to fix common issues..."
            
            # Try to fix common formatting issues
            # Remove any potential whitespace and reformat
            tr -d '\r' < ~/.ssh/deploy_key > ~/.ssh/deploy_key.tmp
            mv ~/.ssh/deploy_key.tmp ~/.ssh/deploy_key
            chmod 600 ~/.ssh/deploy_key
            
            # Try again
            if ssh-keygen -y -f ~/.ssh/deploy_key > ~/.ssh/deploy_key.pub 2>/dev/null; then
              echo "‚úÖ Fixed! SSH key format is now valid"
            else
              echo "‚ùå Still invalid. Please check the EC2_SSH_KEY secret format."
              echo "Instructions for setting up the secret correctly are in docs/SSH_KEY_SETUP.md"
              exit 1
            fi
          fi

      - name: Deploy to EC2
        run: |
          echo "üöÄ Deploying to EC2..."
          
          # Add SSH config for better debugging
          cat > ~/.ssh/config <<EOF
          Host ec2-instance
            HostName ${{ env.EC2_HOST }}
            User ${{ env.EC2_USER }}
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
            LogLevel DEBUG
          EOF
          chmod 600 ~/.ssh/config
          
          # Create deployment directory on EC2
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ env.EC2_USER }}@${{ env.EC2_HOST }} \
            "mkdir -p ~/deployment-tmp"
          
          # Transfer Docker images
          echo "üì§ Transferring Docker images to EC2..."
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            prism-server.tar.gz prism-web.tar.gz \
            ${{ env.EC2_USER }}@${{ env.EC2_HOST }}:~/deployment-tmp/
          
          # Create deployment script
          cat > deploy-script.sh <<'EOF'
          #!/bin/bash
          set -e
          
          echo "üîÑ Loading Docker images..."
          cd ~/deployment-tmp
          
          # Load images
          docker load < prism-server.tar.gz
          docker load < prism-web.tar.gz
          
          echo "üìÅ Setting up deployment directory..."
          DEPLOY_DIR=~/prism-deployment
          mkdir -p ${DEPLOY_DIR}/data ${DEPLOY_DIR}/config
          cd ${DEPLOY_DIR}
          
          echo "üßπ Cleaning up existing containers..."
          # Force remove any existing containers with these names
          docker rm -f prism-server prism-nginx prism-database 2>/dev/null || true
          
          # Also try to stop and remove using docker-compose if it exists
          if [ -f docker-compose.production.yml ]; then
            docker compose -f docker-compose.production.yml down --remove-orphans || true
          fi
          
          # Create docker-compose.yml for production
          cat > docker-compose.production.yml <<'COMPOSE'
          
          services:
            server:
              image: prism-server:latest
              container_name: prism-server
              restart: unless-stopped
              environment:
                - PRISM_SERVER_HOST=0.0.0.0
                - PRISM_SERVER_PORT=8081
                - PRISM_API_PORT=8080
                - PRISM_LOG_LEVEL=INFO
                - PRISM_DATABASE_PATH=/data/prism.db
              volumes:
                - ./data:/data
                - ./config:/app/config
              ports:
                - "8080:8080"
                - "8081:8081"
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8080/api/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
          
            nginx:
              image: prism-web:latest
              container_name: prism-nginx
              restart: unless-stopped
              ports:
                - "80:80"
              depends_on:
                - server
              environment:
                - API_URL=http://server:8080
          COMPOSE
          
          echo "üöÄ Starting new containers..."
          docker compose -f docker-compose.production.yml up -d
          
          echo "‚è≥ Waiting for services to start..."
          sleep 30
          
          echo "üîç Checking container status..."
          docker compose -f docker-compose.production.yml ps
          
          # Verify services are running
          echo "üè• Health check..."
          if docker ps | grep -q prism-server && docker ps | grep -q prism-nginx; then
            echo "‚úÖ All containers are running"
          else
            echo "‚ùå Some containers failed to start"
            docker compose -f docker-compose.production.yml logs
            exit 1
          fi
          
          echo "üßπ Cleaning up deployment files..."
          rm -rf ~/deployment-tmp
          docker image prune -f
          
          echo "‚úÖ Deployment complete!"
          echo "üìç Services deployed to: ${DEPLOY_DIR}"
          EOF
          
          # Transfer and execute deployment script
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            deploy-script.sh \
            ${{ env.EC2_USER }}@${{ env.EC2_HOST }}:~/deployment-tmp/
          
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ env.EC2_USER }}@${{ env.EC2_HOST }} \
            "chmod +x ~/deployment-tmp/deploy-script.sh && ~/deployment-tmp/deploy-script.sh"
          
          # Clean up
          rm -f ~/.ssh/deploy_key deploy-script.sh

      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment..."
          
          # Wait for services to stabilize
          sleep 15
          
          # Check API health
          if curl -f http://${{ env.EC2_HOST }}:8080/api/health; then
            echo "‚úÖ API health check passed"
          else
            echo "‚ùå API health check failed"
            exit 1
          fi
          
          # Check web interface
          if curl -f http://${{ env.EC2_HOST }}; then
            echo "‚úÖ Web interface check passed"
          else
            echo "‚ùå Web interface check failed"
            exit 1
          fi
          
          echo "‚úÖ All services are healthy!"

      - name: Clean up local artifacts
        if: always()
        run: |
          rm -f prism-server.tar.gz prism-web.tar.gz
          rm -f ~/.ssh/deploy_key deploy-script.sh

      - name: Generate deployment summary
        if: always()
        run: |
          echo "# üöÄ Direct Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Target**: EC2 Instance at ${{ env.EC2_HOST }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Method**: Direct image transfer (no registry)" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered By**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Services" >> $GITHUB_STEP_SUMMARY
          echo "- **Web Interface**: http://${{ env.EC2_HOST }}/" >> $GITHUB_STEP_SUMMARY
          echo "- **API**: http://${{ env.EC2_HOST }}:8080/api/health" >> $GITHUB_STEP_SUMMARY
          echo "- **TCP Server**: ${{ env.EC2_HOST }}:8081" >> $GITHUB_STEP_SUMMARY