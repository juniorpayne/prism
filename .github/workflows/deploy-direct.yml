name: Direct Deploy to EC2

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      deploy_monitoring:
        description: 'Deploy monitoring stack'
        required: false
        default: 'false'
        type: boolean

env:
  EC2_HOST: 35.170.180.10
  EC2_USER: ubuntu
  SERVER_IMAGE: 'prism-server:latest'
  WEB_IMAGE: 'prism-web:latest'

jobs:
  build-and-deploy:
    name: Build and Deploy Directly to EC2
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build production server image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.production
          target: production
          push: false
          load: true
          tags: ${{ env.SERVER_IMAGE }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build web interface image
        uses: docker/build-push-action@v5
        with:
          context: ./web
          file: ./web/Dockerfile
          target: production
          push: false
          load: true
          tags: ${{ env.WEB_IMAGE }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Save Docker images with integrity checks
        run: |
          echo "üíæ Saving Docker images to tarballs..."
          
          # Save without piping to avoid potential issues
          echo "Saving server image..."
          docker save -o prism-server.tar ${{ env.SERVER_IMAGE }}
          gzip -6 prism-server.tar
          
          echo "Saving web image..."
          docker save -o prism-web.tar ${{ env.WEB_IMAGE }}
          gzip -6 prism-web.tar
          
          # Generate checksums
          sha256sum prism-server.tar.gz > prism-server.tar.gz.sha256
          sha256sum prism-web.tar.gz > prism-web.tar.gz.sha256
          
          # Verify compressed files
          echo "Verifying compressed files..."
          gzip -t prism-server.tar.gz || { echo "Server image compression failed!"; exit 1; }
          gzip -t prism-web.tar.gz || { echo "Web image compression failed!"; exit 1; }
          
          # Display file info
          echo "File information:"
          ls -lah *.tar.gz
          echo "Checksums:"
          cat *.sha256

      - name: Debug Environment
        run: |
          echo "üîç Debugging workflow environment..."
          echo "Repository: ${{ github.repository }}"
          echo "Actor: ${{ github.actor }}"
          echo "Event: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Workflow: ${{ github.workflow }}"
          
      - name: Setup SSH Authentication
        env:
          SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          echo "üîê Setting up SSH authentication..."
          
          # Create SSH directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Debug: Check if secret exists by checking its length
          echo "üîç Checking if EC2_SSH_KEY secret exists..."
          SECRET_LENGTH=$(echo -n "${SSH_KEY}" | wc -c)
          echo "Secret length: ${SECRET_LENGTH} characters"
          
          if [ "$SECRET_LENGTH" -lt 10 ]; then
            echo "‚ùå EC2_SSH_KEY secret appears to be empty or too short!"
            echo "Please ensure the secret is properly set in GitHub repository settings."
            echo "To set it, run: gh secret set EC2_SSH_KEY < citadel.pem"
            exit 1
          fi
          
          # Save SSH key with multiple format attempts
          echo "üìù Attempting to save SSH key..."
          
          # Method 1: Use environment variable
          echo "${SSH_KEY}" > ~/.ssh/deploy_key
          
          # Ensure proper permissions
          chmod 600 ~/.ssh/deploy_key
          
          # Debug: Check key file
          echo "üîç Key file info:"
          ls -la ~/.ssh/deploy_key
          echo "First line of key:"
          head -n 1 ~/.ssh/deploy_key
          echo "Last line of key:"
          tail -n 1 ~/.ssh/deploy_key
          echo "Line count:"
          wc -l ~/.ssh/deploy_key
          
          # Try to extract public key (this will fail if format is wrong)
          echo "üîë Testing key format..."
          if ssh-keygen -y -f ~/.ssh/deploy_key > ~/.ssh/deploy_key.pub 2>/dev/null; then
            echo "‚úÖ SSH key format appears valid"
            echo "Public key:"
            cat ~/.ssh/deploy_key.pub
          else
            echo "‚ùå SSH key format is invalid!"
            echo "Common issues:"
            echo "1. Key should start with '-----BEGIN RSA PRIVATE KEY-----' or '-----BEGIN OPENSSH PRIVATE KEY-----'"
            echo "2. Key should end with '-----END RSA PRIVATE KEY-----' or '-----END OPENSSH PRIVATE KEY-----'"
            echo "3. Each line should be no more than 64 characters (except first and last)"
            echo "4. No extra spaces or characters"
            echo ""
            echo "Attempting to fix common issues..."
            
            # Try to fix common formatting issues
            # Remove any potential whitespace and reformat
            tr -d '\r' < ~/.ssh/deploy_key > ~/.ssh/deploy_key.tmp
            mv ~/.ssh/deploy_key.tmp ~/.ssh/deploy_key
            chmod 600 ~/.ssh/deploy_key
            
            # Try again
            if ssh-keygen -y -f ~/.ssh/deploy_key > ~/.ssh/deploy_key.pub 2>/dev/null; then
              echo "‚úÖ Fixed! SSH key format is now valid"
            else
              echo "‚ùå Still invalid. Please check the EC2_SSH_KEY secret format."
              echo "Instructions for setting up the secret correctly are in docs/SSH_KEY_SETUP.md"
              exit 1
            fi
          fi

      - name: Deploy to EC2 with verification
        run: |
          echo "üöÄ Deploying to EC2..."
          
          # Add SSH config for better debugging
          cat > ~/.ssh/config <<EOF
          Host ec2-instance
            HostName ${{ env.EC2_HOST }}
            User ${{ env.EC2_USER }}
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
            LogLevel DEBUG
          EOF
          chmod 600 ~/.ssh/config
          
          # Check remote disk space first
          echo "üíæ Checking remote disk space..."
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ env.EC2_USER }}@${{ env.EC2_HOST }} \
            "df -h ~/ && mkdir -p ~/deployment-tmp"
          
          # Transfer Docker images with checksums
          echo "üì§ Transferring Docker images to EC2..."
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -C \
            prism-server.tar.gz prism-server.tar.gz.sha256 \
            prism-web.tar.gz prism-web.tar.gz.sha256 \
            ${{ env.EC2_USER }}@${{ env.EC2_HOST }}:~/deployment-tmp/
          
          # Verify checksums on remote
          echo "üîç Verifying file integrity on remote..."
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ env.EC2_USER }}@${{ env.EC2_HOST }} \
            "cd ~/deployment-tmp && sha256sum -c *.sha256"
          
          # Transfer monitoring configuration if deploying monitoring
          if [ "${{ inputs.deploy_monitoring }}" == "true" ] || [ "${{ github.event.inputs.deploy_monitoring }}" == "true" ]; then
            echo "üìä Transferring monitoring configuration..."
            tar -czf monitoring.tar.gz docker-compose.monitoring.yml monitoring/
            scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
              monitoring.tar.gz \
              ${{ env.EC2_USER }}@${{ env.EC2_HOST }}:~/deployment-tmp/
          fi
          
          # Create deployment script
          cat > deploy-script.sh <<'EOF'
          #!/bin/bash
          set -e
          
          echo "üîÑ Starting deployment process..."
          cd ~/deployment-tmp
          
          # Check disk space
          echo "üíæ Disk space available:"
          df -h .
          
          # Verify files exist and are valid
          echo "üîç Verifying deployment files..."
          for file in prism-server.tar.gz prism-web.tar.gz; do
            if [ ! -f "$file" ]; then
              echo "‚ùå Error: $file not found!"
              exit 1
            fi
            
            echo "Checking $file..."
            ls -lah "$file"
            
            # Check if gzip is valid
            if ! gzip -t "$file"; then
              echo "‚ùå Error: $file is corrupted!"
              exit 1
            fi
            
            # Check if tar is valid
            if ! gunzip -c "$file" | tar -t > /dev/null 2>&1; then
              echo "‚ùå Error: $file has invalid tar format!"
              exit 1
            fi
            
            echo "‚úÖ $file is valid"
          done
          
          # Load images with multiple methods
          echo "üê≥ Loading Docker images..."
          
          # Try method 1: gunzip pipe
          echo "Loading prism-server image (method 1)..."
          if gunzip -c prism-server.tar.gz | docker load; then
            echo "‚úÖ Server image loaded successfully"
          else
            echo "‚ö†Ô∏è  Method 1 failed, trying method 2..."
            # Try method 2: direct load
            if docker load < prism-server.tar.gz; then
              echo "‚úÖ Server image loaded successfully (method 2)"
            else
              echo "‚ùå Failed to load prism-server image!"
              exit 1
            fi
          fi
          
          echo "Loading prism-web image (method 1)..."
          if gunzip -c prism-web.tar.gz | docker load; then
            echo "‚úÖ Web image loaded successfully"
          else
            echo "‚ö†Ô∏è  Method 1 failed, trying method 2..."
            # Try method 2: direct load
            if docker load < prism-web.tar.gz; then
              echo "‚úÖ Web image loaded successfully (method 2)"
            else
              echo "‚ùå Failed to load prism-web image!"
              exit 1
            fi
          fi
          
          # Verify images were loaded
          echo "üîç Verifying loaded images..."
          docker images | grep prism || { echo "‚ùå Images not found after loading!"; exit 1; }
          
          # Extract monitoring configuration if present
          if [ -f monitoring.tar.gz ]; then
            echo "üìä Extracting monitoring configuration..."
            tar -xzf monitoring.tar.gz
          fi
          
          echo "üìÅ Setting up deployment directory..."
          DEPLOY_DIR=~/prism-deployment
          mkdir -p ${DEPLOY_DIR}/data ${DEPLOY_DIR}/config
          cd ${DEPLOY_DIR}
          
          echo "üßπ Cleaning up existing containers..."
          # Force remove any existing containers with these names
          docker rm -f prism-server prism-nginx prism-database 2>/dev/null || true
          
          # Also try to stop and remove using docker-compose if it exists
          if [ -f docker-compose.production.yml ]; then
            docker compose -f docker-compose.production.yml down --remove-orphans || true
          fi
          
          # Copy monitoring configuration if it exists
          if [ -d ~/deployment-tmp/monitoring ]; then
            echo "üìä Setting up monitoring configuration..."
            cp -r ~/deployment-tmp/monitoring ${DEPLOY_DIR}/
          fi
          
          # Create docker-compose.yml for production
          cat > docker-compose.production.yml <<'COMPOSE'
          
          services:
            server:
              image: prism-server:latest
              container_name: prism-server
              restart: unless-stopped
              environment:
                - PRISM_SERVER_HOST=0.0.0.0
                - PRISM_SERVER_TCP_PORT=8080
                - PRISM_SERVER_API_PORT=8081
                - PRISM_LOGGING_LEVEL=INFO
                - PRISM_DATABASE_PATH=/data/prism.db
              volumes:
                - ./data:/data
                - ./config:/app/config
              ports:
                - "8080:8080"  # TCP server for client connections
                - "8081:8081"  # REST API for health checks
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8081/api/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
          
            nginx:
              image: prism-web:latest
              container_name: prism-nginx
              restart: unless-stopped
              ports:
                - "8090:80"
              depends_on:
                - server
              environment:
                - API_URL=http://server:8080
          COMPOSE
          
          echo "üöÄ Starting new containers..."
          docker compose -f docker-compose.production.yml up -d
          
          # Deploy monitoring stack if configuration exists
          if [ -f ${DEPLOY_DIR}/docker-compose.monitoring.yml ]; then
            echo "üìä Deploying monitoring stack..."
            docker compose -f docker-compose.monitoring.yml up -d
          fi
          
          echo "‚è≥ Waiting for services to start..."
          sleep 30
          
          echo "üîç Checking container status..."
          docker compose -f docker-compose.production.yml ps
          
          # Verify services are running
          echo "üè• Health check..."
          if docker ps | grep -q prism-server && docker ps | grep -q prism-nginx; then
            echo "‚úÖ All containers are running"
          else
            echo "‚ùå Some containers failed to start"
            docker compose -f docker-compose.production.yml logs
            exit 1
          fi
          
          echo "üßπ Cleaning up deployment files..."
          rm -rf ~/deployment-tmp
          docker image prune -f
          
          echo "‚úÖ Deployment complete!"
          echo "üìç Services deployed to: ${DEPLOY_DIR}"
          EOF
          
          # Transfer and execute deployment script
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            deploy-script.sh \
            ${{ env.EC2_USER }}@${{ env.EC2_HOST }}:~/deployment-tmp/
          
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ env.EC2_USER }}@${{ env.EC2_HOST }} \
            "chmod +x ~/deployment-tmp/deploy-script.sh && ~/deployment-tmp/deploy-script.sh"
          
          # Clean up deployment script only (keep SSH key for verification)
          rm -f deploy-script.sh

      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment..."
          
          # Wait for services to stabilize
          echo "‚è≥ Waiting for services to stabilize..."
          sleep 20
          
          # First, verify services are running on EC2
          echo "üîç Checking container status on EC2..."
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ env.EC2_USER }}@${{ env.EC2_HOST }} \
            "cd ~/prism-deployment && docker compose -f docker-compose.production.yml ps"
          
          # Check API health (on port 8081)
          echo "üîç Checking API health endpoint..."
          if curl -f -m 10 http://${{ env.EC2_HOST }}:8081/api/health; then
            echo "‚úÖ API health check passed"
          else
            echo "‚ùå API health check failed"
            echo "Attempting to get more information..."
            curl -v http://${{ env.EC2_HOST }}:8081/api/health || true
            
            # Check if port is accessible
            echo "üîç Testing port connectivity..."
            nc -zv -w5 ${{ env.EC2_HOST }} 8081 || echo "Port 8081 appears to be blocked"
            
            # Get container logs
            echo "üìã Getting container logs..."
            ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
              ${{ env.EC2_USER }}@${{ env.EC2_HOST }} \
              "cd ~/prism-deployment && docker compose -f docker-compose.production.yml logs --tail=50 server"
            
            exit 1
          fi
          
          # Check web interface (on port 8090)
          echo "üîç Checking web interface..."
          if curl -f -m 10 http://${{ env.EC2_HOST }}:8090/; then
            echo "‚úÖ Web interface check passed"
          else
            echo "‚ùå Web interface check failed"
            echo "Attempting to get more information..."
            curl -v http://${{ env.EC2_HOST }}:8090/ || true
            
            # Check if port is accessible
            echo "üîç Testing port connectivity..."
            nc -zv -w5 ${{ env.EC2_HOST }} 8090 || echo "Port 8090 appears to be blocked"
            
            # Get nginx logs
            echo "üìã Getting nginx logs..."
            ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
              ${{ env.EC2_USER }}@${{ env.EC2_HOST }} \
              "cd ~/prism-deployment && docker compose -f docker-compose.production.yml logs --tail=50 nginx"
            
            exit 1
          fi
          
          echo "‚úÖ All services are healthy!"

      - name: Clean up local artifacts
        if: always()
        run: |
          rm -f prism-server.tar.gz prism-web.tar.gz
          rm -f prism-server.tar.gz.sha256 prism-web.tar.gz.sha256
          rm -f ~/.ssh/deploy_key deploy-script.sh

      - name: Generate deployment summary
        if: always()
        run: |
          echo "# üöÄ Direct Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Target**: EC2 Instance at ${{ env.EC2_HOST }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Method**: Direct image transfer (no registry)" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered By**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Services" >> $GITHUB_STEP_SUMMARY
          echo "- **Web Interface**: http://${{ env.EC2_HOST }}:8090/" >> $GITHUB_STEP_SUMMARY
          echo "- **API**: http://${{ env.EC2_HOST }}:8081/api/health" >> $GITHUB_STEP_SUMMARY
          echo "- **TCP Server**: ${{ env.EC2_HOST }}:8080" >> $GITHUB_STEP_SUMMARY